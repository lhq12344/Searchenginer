整个搜索引擎分为两大部分：关键词推荐和网页查询服务。
一.关键词推荐
	1.离线部分：创建汉字和英文词典和词典索引存放在data文件夹中
				细节：要得到词频并且去掉垃圾词
	2.在线部分：开启服务器后先读取字典和索引文件储存到内存
				字典存储类型为vector<pair<string,int>>
				字典索引类型为unorder_map<string,set<int>>
			   wf作为api网关，将客户端的请求发送给对应的微服务（关键词和网页）
			   	关键词微服务接收到用户请求后，使用分词将请求分词后在对应索引里查找
				将所有查询结果汇总去重
				接下来使用最短编辑距离算法找到最大相似度的n个结果并且返回json

				srpc微服务指令	：srpc_generator protobuf wordsearch.proto . 
								protoc -I. --cpp_out=. pagesearch.proto 2>&1 | sed -n '1,200p'
二.网页查询
	1.离线部分：创建网页搜索库和网页偏移库
				细节：网页清洗
					网页去重（simhasher）
	2.在线部分：
				用户输入分词并且计算权重
				查倒排索引，取出交集（包含所有分词的page）
				计算内积大小并且排序


关键技术：
1.中英文分词原理
2.最短编辑距离
2.simhasher文本相似度算法。网页去重
3.向量空间模型（TF‑IDF + 余弦相似度）
4.LRU缓存
	每次得到offset后通过打开磁盘文件ifstream ifs("../../Make_Page/page/text.dat", ios::binary);
	获取文章内容比较耗时。加入缓存保存。一般的缓存有三种类型：FIFO、LRU，LFU。
	缓存的实现有四种思路：1）redeis 优点是跨进程、跨主机共享数据自带持久化与过期机制支持丰富的数据结构（hash、list、set 等）。
							缺点是网络通信开销（TCP/HTTP）较大需维护连接池、序列化依赖外部服务（可用性风险
						2）公共缓存 优点是内存访问效率极高（纳秒级）命中率高（集中式存储）。
							缺点多线程竞争同一资源，需要加锁保护，加锁可能导致性能瓶颈（尤其写操作）
						3）线程私有缓存 优点是每个线程独立缓存，无锁访问，无竞争，延迟极低。 
							缺点是命中率低（缓存碎片化）线程间数据不一致，需要同步机制
						4）双缓存（在线程缓存的基础上，每个线程两个缓存）
							优点是读写分离：一个缓存负责查询，一个负责后台同步。提升读性能、减少锁竞争，可在后台异步更新数据，一个负责查询工作，一个负责同步工作。
							缺点是实现复杂（需要双缓存切换策略） 内存占用增加一倍
	因为使用了wf异步回调的框架。线程私有缓存和双缓存使用不了。决定使用公共缓存。

	另外wf框架提供了WFResourcePool类。但是该类的使用类似于linux的slab高速缓存，既为了避免频繁申请和销毁数据，提前申请n个某类型的数据放入资源池中。按需拿去和放回。
	
